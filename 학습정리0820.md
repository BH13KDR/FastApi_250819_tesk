(1) API 스펙부터 먼저 작성하기

실무에서는 구현보다 스펙 설계가 우선이다.
더미 데이터를 반환하는 API를 먼저 만들고 배포 → 프론트엔드 개발자가 미리 작업 시작 가능.

(2) FastAPI 초기 세팅 

```python
from fastapi import FastAPI
from fastapi.responses import ORJSONResponse

app = FastAPI(default_response_class=ORJSONResponse)
```
- ORJSON을 사용해 JSON 처리 속도를 극대화.

asgi.py
```python
from app import app

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```
ORJSON을 쓰는 이유
기본 json보다 5배 이상 빠른 성능.
FastAPI에서 대량의 JSON 데이터를 처리할 때 성능 향상에 효과적이다.

(3) 라우터 생성

Meeting Router 예시 (app/apis/v1/meeting_router.py)
```python
from fastapi import APIRouter
from app.dtos.create_meeting_response import CreateMeetingResponse

edgedb_router = APIRouter(prefix="/v1/edgedb/meetings", tags=["Meeting"], redirect_slashes=False)
mysql_router = APIRouter(prefix="/v1/mysql/meetings", tags=["Meeting"], redirect_slashes=False)

@edgedb_router.post("", description="meeting 생성")
async def api_create_meeting_edgedb() -> CreateMeetingResponse:
    return CreateMeetingResponse(url_code="abc")

@mysql_router.post("", description="meeting 생성")
async def api_create_meeting_mysql() -> CreateMeetingResponse:
    return CreateMeetingResponse(url_code="abc")
```
APIRouter를 사용해서 버전, DB별 라우터를 분리.
실제 서비스에서는 DB명을 URL에 넣지 않는 것이 일반적 (강의에서만 예시용으로 사용).

(4) DTO(Data Transfer Object) 활용

app/dtos/create_meeting_response.py
```python
from pydantic import BaseModel, Field
from typing import Annotated
from app.dtos.frozen_config import FROZEN_CONFIG

class CreateMeetingResponse(BaseModel):
    model_config = FROZEN_CONFIG
    url_code: Annotated[str, Field(description="회의 URL 코드. unique 합니다.")]
```

왜 DTO를 쓰는가? : Swagger 자동 문서화 → 필드와 타입 자동 인식.
데이터 안정성 → 불변(frozen) 객체로 만들어서 실수 방지.
가독성 향상 → 반환 타입을 명시적으로 정의해 코드 해석이 쉬워짐.
dict 대신 DTO를 권장하는 이유
dict를 쓰면 key/value 타입 정보가 Swagger에 표시되지 않음.
실수로 잘못된 필드를 넣거나 빼도 런타임 에러가 안 나기 때문에 디버깅이 어려움.

(5) URL용 고유 식별자 생성

고유 식별자의 조건 : 짧고, 고유하고, 알파벳+숫자 조합이어야 함.
uuid4()는 너무 길어서 부적합 → Base62 또는 Sqids 사용.

① Base62 방식 (강의에서 사용)

app/utils/base62.py
```python
import string
from typing import Final, ClassVar

class Base62:
    BASE: Final[ClassVar[str]] = string.ascii_letters + string.digits
    BASE_LEN: Final[ClassVar[int]] = len(BASE)

    @classmethod
    def encode(cls, num: int) -> str:
        if num < 0:
            raise ValueError("양수만 가능합니다.")
        if num == 0:
            return cls.BASE[0]
        result = []
        while num:
            num, remainder = divmod(num, cls.BASE_LEN)
            result.append(cls.BASE[remainder])
        return "".join(result)
```
정수를 62진법 문자열로 변환.
URL-friendly, deterministic(결정적) ID 생성 가능.

② Sqids + 현재 시각 사용

Sqids 라이브러리 활용.
현재 시각(microsecond) + 난수 → 고유 ID 생성.
Base62보다 조금 더 간단하지만, 종속 라이브러리가 하나 추가됨.

(6) 디버깅 중요성

중단점(breakpoint) 설정 → 코드 흐름을 한 단계씩 실행.
Evaluate Expression 기능 → 디버깅 중 원하는 식을 직접 평가.
디버깅 잘하는 개발자가 결국 성장 속도가 빠름.

2. 핵심 개념 정리
| 개념                | 설명                                | 실무 팁                        |
| ------------------ | ---------------------------         | --------------------------- |
| **API 스펙 우선**   | 구현보다 먼저 설계, 더미 응답 배포        | 협업 시 프론트 작업 속도 ↑            |
| **ORJSON**         | JSON 처리 속도 최적화 라이브러리         | 대량 데이터 응답에서 효과적             |
| **APIRouter**      | API를 모듈 단위로 분리                 | `/v1/meetings` 형태의 버전 관리 필수 |
| **DTO(BaseModel)** | 데이터 전달 객체, 필드와 타입을 명확히 정의| Swagger 자동 문서화 지원           |
| **Base62 ID**      | 숫자를 짧은 URL-friendly 문자열로 변환  | uuid보다 가독성 ↑                |
| **Sqids ID**       | 날짜+난수 기반의 압축형 ID              | 별도 라이브러리 필요                 |
| **디버깅**          | 코드 흐름 추적 및 문제 원인 분석         | PyCharm, VSCode 모두 지원       |

3.보충 설명
(1) DTO vs Dict

DTO (권장)

```python
def api() -> CreateMeetingResponse:
    return CreateMeetingResponse(url_code="abc")
```
→ Swagger에서 자동으로 스키마 생성
→ 타입 검증 및 자동 문서화 지원

Dict (비권장)

```python
def api() -> dict[str, str]:
    return {"url_code": "abc"}
```
→ Swagger에서 반환 구조 미노출
→ 개발자가 직접 응답 구조를 문서화해야 함

(2) ID 생성 전략 비교
| 방식        | 길이    | 고유성   | URL 적합성            | 속도 | 종속성   |
| --------- | -----  | -----     | -------------       | --  | ------  |
| `uuid4()` | 36자   | 매우 높음   | 특수문자 포함 → 부적합 | 빠름 | 내장     |
| `Base62`  | 6\~8자 | 높음       | O                   | 빠름 | 없음     |
| `Sqids`   | 6\~8자 | 높음       | O                   | 빠름 | **있음** |


(3) 디버깅 팁

중단점(breakpoint): 실행을 멈추고 현재 상태를 분석.
Step Over: 한 줄씩 실행.
Step Into: 함수 내부 진입.
Evaluate Expression: 코드 중간에 변수, 식을 실시간으로 테스트.
이 스킬은 FastAPI뿐 아니라 SQL, ORM, 비즈니스 로직 디버깅에서도 핵심.

4. 정리

실무형 FastAPI 개발 프로세스
스펙 작성 → 더미 API 구현 → 프론트와 협업
ORJSON으로 성능 최적화
DTO 기반 응답 → Swagger 자동 문서화
Base62/Sqids로 URL-friendly 고유 ID 생성
디버깅으로 코드 흐름 분석 및 문제 해결 능력 강화